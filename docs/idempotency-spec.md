# Спецификация идемпотентности POST операций

## Обзор

Данная спецификация описывает механизм идемпотентности для POST операций в Data Intake Service. Идемпотентность обеспечивает безопасность повторных запросов и предотвращает дублирование операций при сетевых сбоях или retry логике клиентов.

## Принцип работы

### Основные компоненты

1. **Idempotency-Key** - уникальный ключ, предоставляемый клиентом
2. **Request Hash** - SHA-256 хеш тела запроса
3. **State Management** - управление состояниями ключей
4. **TTL (Time To Live)** - время жизни ключей идемпотентности

### Жизненный цикл ключа

```
[Новый запрос] → [Проверка ключа] → [Создание записи] → [Обработка] → [Сохранение ответа]
                     ↓
              [Ключ существует] → [Проверка хеша] → [Возврат кэша] / [Конфликт]
```

## Формат заголовка

### Idempotency-Key

**Тип**: String  
**Обязательность**: Опциональная  
**Формат**: 1-255 символов  
**Допустимые символы**: буквы (a-z, A-Z), цифры (0-9), дефис (-), подчёркивание (_)

**Примеры валидных ключей**:
```
client-request-123
user-456-session-789
2024-01-15-10-30-00-abc123
```

**Примеры невалидных ключей**:
```
@invalid-key#123    # Специальные символы
                    # Пустая строка
very-long-key-...   # Более 255 символов
```

## Состояния ключа

### 1. Processing
- **Описание**: Запрос обрабатывается
- **Условие**: Первый запрос с новым ключом
- **Действие**: Создание записи, обработка запроса
- **Переход**: → Completed (при успехе) / удаление (при ошибке)

### 2. Completed
- **Описание**: Запрос успешно обработан
- **Условие**: Запрос завершён успешно
- **Действие**: Возврат кэшированного ответа
- **Переход**: → Expired (по TTL)

### 3. Expired
- **Описание**: Ключ истёк
- **Условие**: `expires_at < now()`
- **Действие**: Удаление записи, разрешение нового запроса
- **Переход**: → Processing (новый запрос)

## Таблица состояний и таймингов

| Состояние | TTL | GC | Повторный запрос |
|-----------|-----|----|------------------|
| Processing | 1 час | Нет | 409 Conflict |
| Completed | 1 час | Да | 200/201 (кэш) |
| Expired | - | Да | Новый запрос |

## Обработка запросов

### Сценарий 1: Новый ключ
```
POST /api/v1/items
Idempotency-Key: new-key-123
Content-Type: application/json

{
    "sku": "ITEM-001",
    "title": "Sample Item"
}

→ 201 Created (новый item создан)
```

### Сценарий 2: Повторный запрос (тот же ключ + то же тело)
```
POST /api/v1/items
Idempotency-Key: new-key-123
Content-Type: application/json

{
    "sku": "ITEM-001",
    "title": "Sample Item"
}

→ 201 Created (тот же ответ, item не создан повторно)
```

### Сценарий 3: Конфликт (тот же ключ + другое тело)
```
POST /api/v1/items
Idempotency-Key: new-key-123
Content-Type: application/json

{
    "sku": "ITEM-002",
    "title": "Different Item"
}

→ 409 Conflict
{
    "detail": "Idempotency key already used with different request body",
    "error_code": "IDEMPOTENCY_KEY_CONFLICT",
    "idempotency_key": "new-key-123"
}
```

### Сценарий 4: Race condition (параллельные запросы)
```
Запрос 1: POST /api/v1/items (Idempotency-Key: race-key)
Запрос 2: POST /api/v1/items (Idempotency-Key: race-key) [параллельно]

→ Запрос 1: 201 Created
→ Запрос 2: 409 Conflict (processing collision)
```

## Коды ошибок

### 400 Bad Request
```json
{
    "detail": "Invalid idempotency key format. Key must be 1-255 characters long and contain only letters, numbers, hyphens, and underscores",
    "error_code": "INVALID_IDEMPOTENCY_KEY",
    "idempotency_key": "invalid@key#123"
}
```

### 409 Conflict - Разные тела запроса
```json
{
    "detail": "Idempotency key already used with different request body",
    "error_code": "IDEMPOTENCY_KEY_CONFLICT",
    "idempotency_key": "client-key-123"
}
```

### 409 Conflict - Обработка в процессе
```json
{
    "detail": "Request with this idempotency key is already being processed",
    "error_code": "IDEMPOTENCY_KEY_PROCESSING",
    "idempotency_key": "client-key-123"
}
```

## TTL и Garbage Collection

### Время жизни (TTL)
- **По умолчанию**: 1 час (3600 секунд)
- **Настраиваемость**: Через параметр middleware
- **Расчёт**: `expires_at = created_at + TTL`

### Очистка (GC)
- **Частота**: Каждые 10 минут
- **Условие**: `expires_at < now()`
- **Действие**: Удаление записи из БД
- **Логирование**: Количество очищенных записей

### Примеры таймингов

| Время | Действие | Результат |
|-------|----------|-----------|
| T+0 | Первый запрос | 201 Created |
| T+1m | Повторный запрос | 201 Created (кэш) |
| T+10m | Повторный запрос | 201 Created (кэш) |
| T+60m | Повторный запрос | 201 Created (кэш) |
| T+61m | Повторный запрос | 201 Created (новый) |

## Метрики и мониторинг

### Ключевые метрики
- `idempotency.hit` - попадание в кэш (использован существующий ключ)
- `idempotency.miss` - промах (новый ключ)
- `idempotency.conflict` - конфликт (тот же ключ, другое тело)
- `idempotency.processing_collision` - коллизия processing состояния
- `idempotency.cleanup.count` - количество очищенных ключей

### Hit Rate
```
Hit Rate = (idempotency.hit) / (idempotency.hit + idempotency.miss) * 100%
```

**Целевые значения**:
- Hit Rate > 80% - хорошая эффективность
- Hit Rate < 50% - требует анализа

## Рекомендации по использованию

### Для клиентов

1. **Генерация ключей**:
   - Используйте UUID: `uuid4().hex`
   - Или timestamp + random: `{timestamp}-{random}`
   - Избегайте предсказуемых последовательностей

2. **Retry логика**:
   - При 409 Conflict - не повторяйте запрос
   - При 5xx ошибках - используйте тот же ключ
   - При network timeout - используйте тот же ключ

3. **Временные рамки**:
   - Ключи действительны 1 час
   - После истечения можно использовать новый ключ
   - Не полагайтесь на истечение для retry

### Для разработчиков

1. **Тестирование**:
   - Тестируйте race conditions
   - Проверяйте TTL механизм
   - Валидируйте форматы ключей

2. **Мониторинг**:
   - Отслеживайте hit rate
   - Мониторьте количество конфликтов
   - Контролируйте размер таблицы ключей

## Безопасность

### Защита от злоупотреблений
- Ограничение длины ключа (255 символов)
- Валидация формата ключа
- TTL предотвращает накопление ключей
- Автоматическая очистка истёкших записей

### Приватность
- Ключи не содержат чувствительных данных
- Хеши запросов не раскрывают содержимое
- Логирование не включает тела запросов

## Ограничения

1. **Размер ответа**: Максимальный размер кэшируемого ответа не ограничен
2. **Количество ключей**: Ограничено размером БД
3. **Время обработки**: TTL не продлевается при повторных запросах
4. **Только POST**: Идемпотентность работает только для POST запросов

## Миграция и совместимость

### Обратная совместимость
- Запросы без заголовка работают как обычно
- Существующие клиенты не требуют изменений
- Новые клиенты могут использовать идемпотентность

### Версионирование
- Текущая версия: v1.0
- Изменения в формате ключей потребуют новой версии
- TTL изменения обратно совместимы
